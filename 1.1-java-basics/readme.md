# Основы работы Java программ

## JDK / JRE / JVM

![image info](./java.png)

* __JVM__ - виртуальная машина Java - это программа, предназначенная для выполнения байт-кода.
Байт-код создается из исходного текста Java-программы с помощью компилятора __javac__. 
Основное преимущество JVM — это принцип “Write once, run anywhere”. 
Он означает, что приложение, написанное на Java, будет работать одинаково на всех платформах. 
Это является большим преимуществом JVM и самой Java.

* __JRE__ - минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. 
Состоит из виртуальной машины и библиотек Java классов (JRE = JVM + Library Classes). 

* __JDK__ - комплект разработчика приложений на языке Java, включающий в себя компилятор, стандартные библиотеки классов Java, 
примеры, документацию, различные утилиты и исполнительную систему JRE (JDK = JRE + Development Tools). 

## Class loader

__Загрузчики классов__ — это специальные классы, которые являются частью JVM. Они загружают классы в память и делают их доступными для выполнения. 
Загрузчики работают со всеми классами: и с нашими, и с теми, которые непосредственно нужны для работы Java.

Lazy loading - механизм отложенной загрузки классов в Java. Это значит, что загрузка классов не будет выполняться до тех пор, 
пока в приложении не встретится обращение к классу.

### Иерархия загрузчиков классов

![image info](./class-loaders.png)

* __Bootstrap classloader.__ 
Это базовый загрузчик, который загружает все системные классы из архива rt.jar. 
При этом, есть небольшое отличие между загрузкой классов из rt.jar и наших классов: когда JVM загружает классы из rt.jar, 
она не выполняет все этапы проверки, которые выполняются при загрузке любого другого класс-файла т.к. JVM изначально известно, 
что все эти классы уже проверены. Поэтому, включать в этот архив какие-либо свои файлы не стоит.

* __Extension classloader.__
Загружает классы расширений из папки jre/lib/ext. Допустим, вы хотите, чтобы какой-то класс загружался каждый раз при старте Java машины. 
Для этого вы можете скопировать исходный файл класса в эту папку, и он будет автоматически загружаться.

* __System classloader.__ 
Загружает классы из classpath’а, который мы указали при запуске приложения.

Процесс загрузки классов происходит по иерархии:

1. В первую очередь мы запрашиваем поиск в кэше System Class Loader (кэш системного загрузчика содержит классы, которые уже были им загружены);
2. Если класс не был найден в кэше системного загрузчика, мы смотрим кэш Extension Class Loader;
3. Если класс не найден в кэше загрузчика расширений, класс запрашивается у загрузчика Bootstrap.
4. Если класс не найден в кэше Bootstrap, он пытается загрузить этот класс. Если Bootstrap не смог загрузить класс, он делегирует загрузку класса загрузчику расширений. 
Если на этот момент класс будет загружен, он остается в кэше у Extension classloader, а загрузка класса является завершенной.

## Classpath

__Classpath__ – это параметр, который указывает приложениям где искать пользовательские классы. 

Для того, чтобы указать JVM откуда загружать пользовательские классы, нужно воспользоваться переменной CLASSPATH. 
Устанавливать ее мы можем в следующих местах:
1) В глобальных переменных операционной системы.
2) Дополнительным аргументом в утилите cli java (`java -cp HelloWorld.jar Hello`, `-cp` сокращенно от `-classpath`).
3) В манифесте jar-архива.

## Сборка и запуск приложения

```
cd 1.1-java-basics/src
```

Запуск:
```
java run/Main.java
```
Компиляция:
```
javac run/*.java
```
Сборка jar:
```
jar cvfm run/Main.jar run/manifest.txt run/*.class
```
Посмотреть содержимое jar:
```
jar tf run/Main.jar
```
Запуск:
```
java -cp run/Main.jar run.Main
```

## Классы

Java является объектно-ориентированным языком, поэтому такие понятия как "класс" и "объект" играют в нем ключевую роль. 
Любую программу на Java можно представить как набор взаимодействующих между собой объектов.

Шаблоном или описанием объекта является класс, а объект представляет экземпляр этого класса.

### Наследование классов

С помощью наследования можно расширить функционал уже имеющихся классов за счет добавления нового функционала или изменения старого.

* В java нет множественного наследования.
* В иерархии классов конструкторы вызываются в порядке наследования, начиная с суперкласса и заканчивая подклассом.
* Производный класс имеет доступ ко всем методам и полям базового класса (даже если базовый класс находится в другом пакете) кроме тех, которые определены с модификатором private. При этом производный класс также может добавлять свои поля и методы.
* Производный класс может определять свои методы, а может переопределять методы, которые унаследованы от базового класса.
* Хотя наследование очень интересный и эффективный механизм, но в некоторых ситуациях его применение может быть нежелательным. И в этом случае можно запретить наследование с помощью ключевого слова final.

Замечания:

* Если в классе не создать конструктор, будет создан конструктор по умолчанию (без аргументов), со спецификатором доступа, как у класса:
```
public class NoConstructor {
    //конструктора нет
    //будет добавлен конструктор следующего вида
    //public NoConstructor() {
    //}
}
```

* Первой командой конструктора должна быть this (для вызова другого конструктора) или super (для вызова конструктора суперкласса). 
Если этой команды нет - компилятор добавит ее сам. Следующий код не скомпилируется т.к. в суперклассе создан конструктор с аргументом 
и конструктор поумолчанию не будет создан, при этом в конструкторе подкласса нет super или this, следовательно компилятор добавляет super() - вызов несуществующего конструктора без аргумента.
```
class Parent {
    //нет конструктора без аргумента
    Parent(String s) {
    }
}
class Child extends Parent {
    //будет добавлен вызов super();
    Child(int i) {
    }
}
```

## Инициализация полей и блоков класса

static поля и static блоки инициализируются при загрузке класса с помощью classloader.

В общем случае порядок вызова блоков и конструктора следующий:

1. Статические поля и статический блок инициализации;
2. Нестатические поля и нестатический блок инициализации;
3. Конструктор.

### При наследовании классов инициализация происходит в следующем порядке:

1. Статические поля и статический блок инициализации класса Parent;
2. Статические поля и статический блок инициализации класса Child;
3. Нестатические поля и нестатический блок инициализации класса Parent;
4. Конструктор класса Parent;
5. Нестатические поля и нестатический блок инициализации класса Сhild;
6. Конструктор класса Сhild.

```
class Parent {
    static {
        System.out.print("1");
    }

    {
        System.out.print("3");
    }

    Parent() {
        System.out.print("4");
    }
}

class Child extends Parent {
    static {
        System.out.print("2");
    }

    {
        System.out.print("5");
    }

    Child() {
        System.out.print("6");
    }
}

// Output: 123456
```

## Immutable vs Mutable class

__Изменяемый объект (mutable)__ - можно изменить состояние и поля после создания объекта. Например: `StringBuilder`, `java.util.Date` и т.д.

__Неизменяемый объект (immutable)__ - нельзя ничего изменить после создания объекта. Например: `String`, `Integer`, `Byte` и т.д.

### Как сделать класс immutable?

```
public final class Student {

    private final int id; 
    private final String name; 
    private final Address address;

    public Student(int id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Address getAddress() {
        return new Address(address.getCity(), address.getStreet(), ...);
    }
}
```
* Объявляем класс как final, чтобы от него нельзя было наследоваться.
* Делаем все поля private, чтобы закрыть прямой доступ.
* Помечаем все поля final для того, чтобы их значение можно было установить только единожды;
* Не используем сеттеры, используем только конструктор;
* Для полей, которые НЕ являются примитивом или immutable классом, в геттере необходимо возвращать копию объекта, для того, 
чтобы никто извне не мог поменять его значение.
