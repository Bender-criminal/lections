# Основы работы Java программ

## JDK / JRE / JVM

![image info](./java.png)

* __JVM__ - виртуальная машина Java - это программа, предназначенная для выполнения байт-кода.
Байт-код создается из исходного текста Java-программы компилятором javac. 
Основное преимущество JVM — это принцип “Write once, run anywhere”. 
Он означает, что приложение, написанное на Java, будет работать одинаково на всех платформах. 
Это является большим преимуществом JVM и самой Java.

* __JRE__ - минимальная реализация виртуальной машины, необходимая для исполнения Java -приложений, без компилятора и других средств разработки. 
Состоит из виртуальной машины и библиотек Java классов (JRE = JVM + Library Classes). 

* __JDK__ - комплект разработчика приложений на языке Java, включающий в себя компилятор, стандартные библиотеки классов Java, 
примеры, документацию, различные утилиты и исполнительную систему JRE (JDK = JRE + Development Tools). 

## Class loader

Загрузчики классов — это специальные классы, которые являются частью JVM. Они загружают классы в память и делают их доступными для выполнения. 
Загрузчики работают со всеми классами: и с нашими, и с теми, которые непосредственно нужны для Java.

Представьте ситуацию: мы написали свое приложение, и помимо стандартных классов там есть наши классы, и их очень много. Как с этим будет работать JVM? 
В Java реализована отложенная загрузка классов, иными словами lazy loading. Это значит, что загрузка классов не будет выполняться до тех пор, пока в приложении не встретится обращение к классу.

### Иерархия загрузчиков классов

![image info](./class-loaders.png)

* Первый загрузчик классов — это Bootstrap classloader. 
Это базовый загрузчик, который загружает все системные классы из архива rt.jar. 
При этом, есть небольшое отличие между загрузкой классов из rt.jar и наших классов: когда JVM загружает классы из rt.jar, 
она не выполняет все этапы проверки, которые выполняются при загрузке любого другого класс-файла т.к. JVM изначально известно, 
что все эти классы уже проверены. Поэтому, включать в этот архив какие-либо свои файлы не стоит.

* Следующий загрузчик — это Extension classloader. 
Он загружает классы расширений из папки jre/lib/ext. Допустим, вы хотите, чтобы какой-то класс загружался каждый раз при старте Java машины. 
Для этого вы можете скопировать исходный файл класса в эту папку, и он будет автоматически загружаться.

* Еще один загрузчик — System classloader. Он загружает классы из classpath’а, который мы указали при запуске приложения.

Процесс загрузки классов происходит по иерархии:

1. В первую очередь мы запрашиваем поиск в кэше System Class Loader (кэш системного загрузчика содержит классы, которые уже были им загружены);
2. Если класс не был найден в кэше системного загрузчика, мы смотрим кэш Extension class loader;
3. Если класс не найден в кэше загрузчика расширений, класс запрашивается у загрузчика Bootstrap.
4. Если класс не найден в кэше Bootstrap, он пытается загрузить этот класс. Если Bootstrap не смог загрузить класс, он делегирует загрузку класса загрузчику расширений. 
Если на этот момент класс будет загружен, он остается в кэше у Extension classloader, а загрузка класса является завершенной.

## Classpath

Classpath – это параметр, который указывает приложениям где искать пользовательские классы. 

Для того, чтобы указать JVM откуда загружать пользовательские классы, нужно воспользоваться переменной CLASSPATH. 
Устанавливать ее мы можем в следующих местах:
1) В глобальных пременных ОС.
2) Дополнительным аргументом в утилите cli java.
3) В манифесте jar-архива.

## Сборка приложения

// TODO

## Классы

Java является объектно-ориентированным языком, поэтому такие понятия как "класс" и "объект" играют в нем ключевую роль. 
Любую программу на Java можно представить как набор взаимодействующих между собой объектов.

Шаблоном или описанием объекта является класс, а объект представляет экземпляр этого класса.

// TODO

## Статические методы / переменные / блоки

// TODO

## Наследование

// TODO

## Порядок вызова конструкторов

В иерархии классов конструкторы вызываются в порядке наследования, начиная с суперкласса и заканчивая подклассом.
Более того, этот порядок остается неизменным независимо от того, используется super() или нет, поскольку вызов метода super() 
должен быть в первом операторе, выполняемом в конструкторе подкласса.
Если метод super() не вызывается, то используется конструктор по умолчанию или же конструктор без параметровиз каждого суперкласса.

// TODO

## Immutable vs Mutable class

Изменяемый объект (mutable) - можно изменить состояние и поля после создания объекта. Например: `StringBuilder`, `java.util.Date` и т.д.

Неизменяемый объект (immutable) - нельзя ничего изменить после создания объекта. Например: `String` и т.д.

### Как сделать класс immutable?

```
public final class Student {

    private final int id; 
    private final String name; 
    private final Address address;

    public Student(int id, String name, Address address) {
        this.id = id;
        this.name = name;
        this.address = address;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getAddress() {
        return new Address(address.getCity(), address.getStreet(), ...);
    }
}
```

* Помечаем все поля final для того, чтобы нельзя было изменить их значения внутри класса;
* Не используем сеттеры, используем только конструктор;
* Для полей, которые НЕ являются примитивом или immutable классом, в геттере необходимо возвращать копию объекта, для того, 
чтобы никто извне не мог поменять его значение.