# Лекция: Устройство памяти в Java. Garbage Collection

## Устройство памяти в Java

```
||===============================||
||                               ||
||    ||===================||<---||---|
||    ||     New Gen       ||    ||   |
||    || (Eden + Survivor) ||    ||   |
||    ||===================||    ||   | Heap
||    ||                   ||    ||   |
||    ||     Old Gen       ||    ||   |
||    ||===================||<---||---|
||                               ||
||       Metaspace & Stack       ||
||                               ||
||        Native Memory          ||
||===============================||
```

Память делится на Heap, Metaspace и stack.
* heap – основной сегмент памяти, используется для выделения памяти под объекты и JRE классы. Создание нового объекта происходит в heap, здесь работает GC.
* metaspace – хранятся метаданные о классе и статические поля: там хранятся это либо примитивы, либо ссылки на объекты/массивы,
которые сами по себе аллоцированы в heap. Metaspace в Java 8 пришел на замену PermGen, основное отличие которой — возможность динамически расширятся,
ограниченная по умолчанию только размером нативной памяти. Опционально можно задать размер через аргумент `-XX:MaxMetaspaceSize`.
В боевых окружениях желательно всегда задавать размер Metaspace. В случае возникновения ошибки, лечится увеличением MetaSpace, либо
добавлением памяти.
* stack – стековая память в Java работает по схеме LIFO: всякий раз, когда вызывается метод, в памяти стека создается новый блок,
который содержит примитивы и _ссылки_ на другие объекты в методе. Каждый поток имеет свой стек, примитивы и ссылки на локальные переменные хранятся в стеке.
Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода.
Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.

```
[ STACK ]                          [ HEAP ] 
int a: 10;                     ->  MyWrapperObject@21f03b70====||
double b: 10.4;                |   ||     int someField: 11    ||
MyWrapperObject@21f03b70 ------|   ||     String@10112222  ---------- 
......                             ||==========================||    |
                                                                     |
                                                                     |
                                    String@10112222============||<----
                                    || ...                     ||
                                    || ...                     ||
                                    }}=========================||
```

## OutOfMemoryError и StackOverflowError 
При работе с памятью в Java мы обычно сталкиваемся с ошибками OutOfMemoryError.
Эта ошибка вылетает когда недостаточно мета для аллокации нового объекта в heap,
GC не может очистить место и heap больше не может расширится.  
Приведем самые распространенные случаи ошибок, связанных с памятью:

### StackOverflowError
[Пример](src/main/java/ru/digiralhabbits/lecture/gc/Stackoverflow.java)

**Причина:** при каждом вызове метода в стеке создается новый блок и туда кладутся аргументы, с какими был вызван метод, и локальные переменные.
В результате при глубокой рекурсии память, выделенная под стек, просто заканчивается. 
**Решение:** развернуть рекурсию с помощью стека, либо сократить количество локальных переменных и передаваемых аргументов.

### OutOfMemoryError: Requested array size exceeds VM limit
[Пример](src/main/java/ru/digiralhabbits/lecture/gc/OutOfMemoryArraySize.java)

**Причина:** приложение пытается аллоцировать массив больше чем размер heap.
**Решение:** чаще всего связано с тем, что приложение _ошибочно_ пытается создать такой большой массив.
В случае, если такое поведение корректно, то требуется увеличить heap.

### OutOfMemoryError: Java heap space
[Пример](src/main/java/ru/digiralhabbits/lecture/gc/OutOfMemoryHeapSpace.java)

**Причина:** объект не может быть создан в heap. Ошибка не всегда свидетельствует об утечке памяти, иногда просто означает,
что заданы некорректные лимиты. Объем памяти регулируется параметрами `-Xms` и `-Xmx`, нижний и верхний размер соответственно.
Иногда нижнюю и верхнюю границу устанавливают равными, например, на серверах где будет только одно приложение,
т.к. в случае динамического увеличения требуется лишнее время на работу с памятью.
**Решение:** увеличить размер heap `-Xmx`.

### OutOfMemoryError: Metaspace
[Пример](src/main/java/ru/digiralhabbits/lecture/gc/OutOfMemoryMetaspace.java)

**Причина:** как говорилось выше, в Metaspace хранится метаданные классов и статические поля. Все статические поля инициализируются
OutOfMemoryError вылетает когда не остается места для создания нового класса.
**Решение:** увеличить размер Metaspace `-XX:MetaspaceSize`.

###  OutOfMemoryError: GC Overhead limit exceeded
**Причина:** выбрасывается Java машиной в случае, если GC работает постоянно, тем самым критически замедляя работу приложения.
Если Java процесс тратит 98% времени на GC и при этом очищает всего 2% свободного места, это повторяется как минимум 5 раз, то выбрасывается исключение
OutOfMemoryError: GC Overhead limit exceeded.  
**Решение:** добавление памяти в heap.  
В ParallelGC и CMS возможно отключение такого поведения ключом `-XX:UseGCOverheadLimit`.

### OutOfMemoryError: Unable to create new native thread
[Пример](src/main/java/ru/digiralhabbits/lecture/gc/OutOfMemoryNativeThread.java)

**Причина:** приложению не хватает ресурсов, чтобы создать новый поток. Чаще всего причина в том, что мы упираемся в лимит открытых дескрипторов на поток в ОС.
Проверить это можно вызвав команду `ulimit -u`.  
Т.к. поток создается не в JVM, а на уровне ОС, в редких случаях это связано с тем, что на самой ОС не хватает ресурсов. Например, на машине 6Gb, 5Gb отдано под heap, 512Mb Metaspace,
под ОС остается только 512Mb.
**Решение**: проверить лимит количества дескрипторов или увеличить память.

## Утечки памяти

Существует множество способов ~~выстрелить себе в ногу~~ получить утечку памяти, рассмотрим несколько из них:
* _finalize методы_ – вместо того, чтобы освободить память при очередном цикле GC, такие объекты помещаются в специальную очередь для вызова finalize.
Для обработки этой очереди используется специальный демон, он имеет приоритет, и если в программе есть потоки с большим приоритетом, то он может начать не успевать разбирать эту очередь. 
* _статические поля и singleton классы_ – статические объекты хранятся в памяти все время работы приложения.
* _thread-local переменные_ – такие переменные хранятся в связке с потоком, но т.к. потоки переиспользуются в пулах, следовательно, эти переменные не будут собраны GC.
* _незакрытые ресурсы_ – всякий раз, когда создается новое соединение или открывается поток, JVM выделяет память для этих ресурсов.
В случае, если эти ресурсы не закрыты, может возникнуть блокировка памяти, тем самым делая их недоступными для сборщика мусора.
В том числе, это может произойти даже в случае возникновения исключения, которое не позволит программе выполнить код, отвечающий за закрытие ресурсов.
* _нестатические внутренние классы_ – каждый нестатический внутренний класс по умолчанию имеет неявную (скрытую) ссылку на класс в котором он находится.
Если мы используем этот объект внутреннего класса в нашем приложении, то даже после того, как объект внешнего класса завершает свою работу,
он не будет утилизирован GC. 
* _неверная реализация `equals` и `hashCode`_ – если для ключа в `HashMap`, `HashSet` используется объект, то он должен корректно реализовывать методы `equals` и `hashCode`,
т.к. иначе может быть ситуация, когда в коллекцию добавляется уже _существующий_ объект, но `equals` и `hashCode` отработали неправильно и _такой же_ объект снова был добавлен.  

## Ключи JVM
1. -XX:+HeapDumpOnOutOfMemoryError – dump в случае OutOfMemory.
1. -Xms, -Xmx – размер heap. Иногда задают равными, чтобы не требовалось дополнительного выделения памяти.
1. -XX:MetaspaceSize – размер Metaspace.
1. -Xss – размер стека.

## Работа с профилировщиком
1. Скачать [jProfiler](https://www.ej-technologies.com/download/jprofiler/trial).
1. Запустить класс [MemoryAnalyze](src/main/java/ru/digiralhabbits/lecture/gc/MemoryAnalyze.java), он будет в бесконечном цикле создавать локальные переменные.
1. Подключиться с помощью jProfiler к MemoryAnalyze, открыть вкладку Telemetries -> Overview.
![jProfiler Overview](images/jProfiler%20Overview.png)
Здесь показано состояние памяти в heap (первая строка) и активность GC (вторая строка).
В момент запуска GC размер свободной памяти в heap увеличивается. Потом в процессе работы цикла и создания новых переменных,
память постепенно снова заканчивается.
1. Переключиться на вкладку Live Memory -> All Object.
![Memory Snapshot](images/Memory%20Snapshot.png).
Здесь показано что именно находится внутри heap'а: название класса, количество экземпляров и занимаемый объем.

Профилировщики оказывают серьезное влияние на производительность программы, поэтому запускать их на боевых серверах категорически нельзя.

В случае, если приложение падает по OutOfMemoryError и в непонятно что происходит, следует запустить его с флагами `-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/dump.bin`,
а полученный heap dump открыть с помощью анализатора. Дамп покажет состояние heap в момент падения, в том числе какие объекты были в нем (со значениями этих объектов,
т.е. из heap dump'а можно достать значения переменных, например пароли).
![Heap Dump](images/Heap%20Dump.png)
![Heap Dump Object Values](images/Heap%20Dump%20Object%20Values.png)

## Garbage Collectors

В Java процесс работы с памятью скрыт от программиста: JVM сама занимается выделением памяти и ее очисткой. Процесс очистки памяти называется Garbage Collection.
Из названия следует, что GC занимается очисткой памяти от "мусора", т.е. удаляет неиспользуемые объекты из памяти. Весь процесс состоит из двух частей:  
* mark – обход дерева объектов и поиск достижимых ссылок из корневых объектов (GC Roots).
* sweep – удаление неиспользуемых объектов.

#### Поиск мусора
1. Reference counting – у каждого объекта счетчик ссылок. Когда он равен нулю, объект считается мусором. В случае обнаружения цикличных ссылок, объекты считаются недостижимыми, если на них не ссылаются никакие другие объекты.
2. Tracing - объект считается не мусором, если до него можно добраться с корневых точек.

#### GC Roots:
* Классы, загруженные системным ClassLoader'ом. Эти классы никогда не могут быть выгружены.
* Активные потоки.
* Локальные переменные, параметры методов.
* Объекты, используемые в мониторе для синхронизации.
* JNI (Java Native Interface).
* Объекты, огражденные от сборки мусора самим JVM.

#### Проблемы при работе Garbage Collector
При обычном удалении объектов появляется фрагментация памяти, и под новые объекты достаточно большого объема
просто не найдется достаточного непрерывного куска памяти, хотя в сумме памяти хватает. Поэтому требуется занимаемые
объекты как-то "сжимать" или переносить в другую область памяти (Survivor Space).
В момент, когда происходит манипуляции с памятью все потоки переводятся в режим ожидания (Stop The World - STW)
потому что ссылки становятся невалидными и их требуется перезаписать все сразу.

Момент STW крайне критичен, т.к. для приложений с большим размером heap (8Gb, например) время простоя может быть вплоть до нескольких секунд,
что недопустимо на боевых серверах. Так же процесс сборки мусора затратен с точки зрения ЦП, т.к. требует больших вычислений достижимости объектов. 
(если вы в мониторинге видите скачок ЦП, то имеет смысл сразу фазу GC, возможно причина в этом).

#### Разделение памяти Heap
Heap – основной сегмент памяти, где хранятся все ваши объекты. Heap делится на два подсегмента, Old Generation и Young Generation.
Young Generation в свою очередь делится на Eden и два сегмента Survivor. По-умолчанию Young Generation занимает одну треть всей кучи,
а Old Generation, соответственно, две трети. При этом каждый регион Survivor занимает одну десятую Young Generation поколения,
то есть Eden занимает восемь десятых.

* _Eden Space_ — в этой области выделяется память под все создаваемые программой объекты.
* _Survivor Space_ — здесь хранятся перемещенные из Eden Space объекты после первой сборки мусора. Объекты, пережившие несколько сборок мусора, перемещаются в следующую сборку Tenured Generation.
* _Tenured Generation_ хранит долгоживущие объекты. Когда данная область памяти заполняется, выполняется полная сборка мусора (full GC).
```
                      ______________________
                     |    Survivor Space    |
                     v                      v
||===========================================================================||
||                  ||          ||          ||                               ||
||                  ||          ||          ||                               ||
||       Eden       ||    S0    ||    S1    ||          Tenured              ||
||                  ||          ||          ||                               ||
||                  ||          ||          ||                               ||
||===========================================================================||
 ^              Young Generation            ^^         Old Generation        ^
 |__________________________________________||_______________________________|
```


### Алгоритмы GC
#### Mark-Sweep Algorithm
Алгоритм помечает неиспользуемые объекты и просто удаляет их. В результате работы получается сильно фрагментированная область памяти.
![Mark-Sweep Algorithm](images/Mark-Sweep%20Algorithm.png)

### Copying Algorithm
Алгоритм делит всю доступную память на два участка, только один участок активен в момент времени. После получения списка живых объектов,
они копируются в другую область памяти, а текущая область полностью очищается.  
![Copying Algorithm](images/Copying%20Algorithm.png)

### Mark-Compact Algorithm
Алгоритм похож на Mark-Sweep алгоритм, но он решает проблему фрагментации памяти: все живые объекты сдвигаются к началу блока памяти.
![Mark-Compact Algorithm](images/Mark-Compact%20Algorithm.png)

### Реализации GC
### SerialGC и ParallelGC
Когда нет места в Eden, запускается GC, живые объекты копируются в S1. Вся область Eden очищается. S1 и S2 меняются местами.
При последующих циклах в S1 будут записаны живые объекты как из Eden, так и из S2. После нескольких циклов обмена S1 и S2 или заполнения области S2,
объекты, которые живут достаточно долго, перемещаются в Old Generation. Когда после очередной сборки мусора места не хватает уже в Young Generation,
то запускается сбор мусора в Old Generation (наряду со сборкой Young Generation). В old Generation объекты уплотняются (алгоритм Mark-Sweep-Compact).
В случае, если объект достаточно велик, он сразу размещается в Tenured (Old Generation) чтобы не таскать его между областями.

Перенос объектов между Eden -> Survivor -> Old Generation  
![SerialGC young](images/SerialGC%20young.png)

Full GC  
![SerialGC full](images/SerialGC%20full.png)    
ParallelGC то же, что и SerialGC, но использует для работы несколько потоков. Включается параметром `-XX:+UseParallelGC`

### CMS (Concurrent Mask Sweep)
Принцип работы с Young Generation такой же, как и в случае алгоритмов Serial и Parallel, отличия в том, что данный алгоритм
разделяет младшую (Young Generation) и старшую (Old Generation) сборку мусора во времени. Причем сбор мусора в Old Generation происходит в отдельном потоке,
независимо от младшей сборки. При этом сначала приложение останавливается, сборщик помечает все живые объекты доступные из GC Root напрямую,
затем приложение вновь начинает работу, а сборщик проверяет объекты доступные по ссылкам из этих самых помеченных,
и также помечает их как живые. Эта особенность создает так называемые плавающие объекты, которые помечены как живые,
но таковыми по факту не являющимися. Но они будут удалены в следующих циклах. Т.е. пропускная способность растет, STW уменьшается,
но требуется больше места для хранения плавающих объектов.  
![CMS Stop The World](images/CMS%20STW.png)
Сборщик CMS достаточно интеллектуальный, он старается разносить во времени малые и старшие сборки мусора,
чтобы они совместно не создавали продолжительных пауз в работе приложения. Для этого он ведет статистику по прошедшим сборкам
и исходя из нее планирует последующие. Отдельно следует рассмотреть ситуацию, когда сборщик не успевает очистить Old Generation до того момента,
как память полностью заканчивается. В этом случае работа приложения останавливается, и вся сборка производится в последовательном режиме.  
В этом алгоритме уплотнения нет. Т.е. область Old Generation фрагментирована. Включается параметром `-XX:+UseConcMarkSweepGC`.

### G1 (Garbage First)
Здесь память разбивается на множество регионов одинакового размера. Размер этих регионов зависит от общего размера кучи и по умолчанию выбирается так,
чтобы их было не больше 2048, обычно получается от 1 до 32 МБ. Исключение составляют только так называемые громадные (humongous) регионы,
которые создаются объединением обычных регионов для размещения очень больших объектов.  
![G1 memory](images/G1%20memory.png)
Разделение регионов на Eden, Survivor и Tenured в данном случае логическое, регионы одного поколения
не обязаны идти подряд и даже могут менять свою принадлежность к тому или иному поколению.  
Малые сборки выполняются периодически для очистки младшего поколения и переноса объектов в регионы Survivor,
либо их повышения до старшего поколения с переносом в Tenured. Над переносом объектов трудятся несколько потоков,
и на время этого процесса работа основного приложения останавливается. Это уже знакомый нам подход из рассмотренных ранее сборщиков,
но отличие состоит в том, что очистка выполняется не на всем поколении, а только на части регионов, которые сборщик сможет очистить
не превышая желаемого времени. При этом он выбирает для очистки те регионы, в которых, скопилось наибольшее количество мусора
и очистка которых принесет наибольший результат. Отсюда как раз название Garbage First — мусор в первую очередь.

G1 для полной сборки (тут она называется mixed) существует процесс, называемый циклом пометки (marking cycle),
который работает параллельно с основным приложением и составляет список живых объектов.
* Initial mark. Пометка корней (с остановкой основного приложения) с использованием информации, полученной из малых сборок.
* Concurrent marking. Пометка всех живых объектов в куче в нескольких потоках, параллельно с работой основного приложения.
* Remark. Дополнительный поиск не учтенных ранее живых объектов (с остановкой основного приложения).
* Cleanup. Очистка вспомогательных структур учета ссылок на объекты и поиск пустых регионов, которые уже можно использовать для размещения новых объектов. 
Первая часть этого шага выполняется при остановленном основном приложении.  
![G1 mixed](images/G1%20mixed.png)

После окончания цикла пометки G1 переключается на выполнение смешанных сборок. Это значит, что при каждой сборке
к набору регионов младшего поколения, подлежащих очистке, добавляется некоторое количество регионов старшего поколения.
Количество таких сборок и количество очищаемых регионов старшего поколения выбирается
исходя из имеющейся у сборщика статистики о предыдущих сборках таким образом, чтобы не выходить за требуемое время сборки.
Как только сборщик очистил достаточно памяти, он переключается обратно в режим малых сборок.
Включается параметром `-XX:+UseG1GC`.

#### Shenandoah

## Ссылки
1. [https://medium.com/@alitech_2017/how-does-garbage-collection-work-in-java-cf4e31343e43](https://medium.com/@alitech_2017/how-does-garbage-collection-work-in-java-cf4e31343e43)
1. [Troubleshoot Memory Leaks](https://docs.oracle.com/en/java/javase/11/troubleshoot/troubleshoot-memory-leaks.html)
1. [Understand the OutOfMemoryError Exception](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html) 
1. [OutOfMemoryError: поймай, если сможешь](https://habr.com/ru/post/359300/)
1. [Garbage Collection наглядно](https://habr.com/ru/post/112676/)
1. [JVM Tuning](https://docs.gigaspaces.com/latest/production/production-jvm-tuning.html)
1. [What Causes OutOfMemoryError?](https://dzone.com/articles/what-causes-outofmemoryerror)
1. [Память Java процесса по полочкам](https://www.youtube.com/watch?v=kKigibHrV5I)
1. [JVM: краткий курс общей анатомии](https://www.youtube.com/watch?v=-fcj6EL9rc4)
1. [https://topjava.ru/blog/java-memory-leaks](https://topjava.ru/blog/java-memory-leaks)
1. [Дюк, вынеси мусор! (3 части)](https://habr.com/ru/post/269621/)
1. [Shenandoah GC](https://wiki.openjdk.java.net/display/shenandoah/Main)
1. [Garbage Collector Wiki](https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29)