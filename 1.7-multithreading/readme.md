# Многопоточность в Java

## Процессы и потоки

Процессы и потоки - две основные концепции многопоточной разработки. В Java - это в основном про потоки.

Деление на процессы и потоки позволяет операционной системе выполнять множество задач одновременно даже при недостатке процессорных ядер. Использование потоков даже на недостаточном количестве ядер позволяет писать единый код, который будет работать быстрее в многоядерных и многопроцессорных системах, при этом он почти не будет иметь негативных эффектов на одноядерных системах при недостатке мощности. Особенно критично потоки использовать в GUI-системах во избежание фризов системы при обработке тяжелых запросов - в этом случае обычно используется UI-поток, который отвечает за быструю отрисовку компонентов пользователю и больше ни за что. В веб-системах многопоточная работа позволяет обрабатывать одновременно много запросов от пользователей или других сервисов, а так же более равномерно загружать ресурсы системы (например, освобождать процессор для обработки других потоков, пока текущий ожидает ответа от базы данных или других сервисов).

### Процесс

Процесс имеет собственное окружение запуска, имеет законченный набор собственных ресурсов и собственную выделенную процессу память. Для взаимодействия между собой процессы могут использовать пайпы (pipes), сокеты (sockets) либо другие способы в зависимости от операционной системы. Это называется Inter Process Communication (IPC).

### Поток

Поток - это "облегченный процесс". Создание потока требует меньше ресурсов. Потоки существуют внутри процесса - и каждый процесс имеет как минимум один поток. Потоки разделяют между собой ресурсы процесса - включая память и открытые файлы. В этом есть плюсы и минусы - увеличивается эффективность использования ресурсов, но одновременно появляются проблемы с их совместным использованием.

С точки зрения Java-разработчика - любое приложение стартует процесс с единственным main-потоком. С точки зрения JVM - кроме main-потока запускаются еще несколько "сервисных" потоков - для управления памятью и сигналами.


## Создание потоков 

1. Используя класс `Thread` можно создать объект потока и непосредственно управлять его выполнением через методы класса.
1. Используя дополнительные возможсности в виде сервисов-исполнителей (executors) - можно отправлять задачи на выполнение для автоматического запуска в зависимости от конфигурации исполнителей.

### Определение и запуск потока

#### Имплементировать `Runnable` интерфейс

```java
public class DigitalHabits implements Runnable {
    public void run() {
        System.out.println("I'm from a thread");
    }

    public static void main(String args[]) {
        (new Thread(new DigitalHabits())).start();
        System.out.println("I'm from the main thread.");
    }
}
```

#### Расширить `Thread` класс

```java
public class DigitalHabits extends Thread {

    @Override
    public void run() {
        System.out.println("I'm from a thread");
    }

    public static void main(String args[]) {
        (new DigitalHabits()).start();
        System.out.println("I'm from the main thread.");
    }
}
```

#### implements `Runnable` vs extends `Thread`

Вариант имплементации интерфейса `Runnable` - более гибкий, т.к. позволяет делать запускаемыми любые классы и более гибко решать задачи асинхронного запуска в больших системах. Вариант с наследованием от класса `Thread` - вполне годится для небольших задач и простых приложений где не требуется низкая связность и не предполагается длительного цикла разработки.


## `Thread.sleep`

Метод `Thread.sleep` переводит текущий поток в состояние ожидания. Это позвляет другим потокам работать. `sleep` так же может быть прерван исключением `InterruptedException` в случае если другой поток прервет текущий поток в сосотянии сна. `sleep` не гарантирует точного времени сна, поэтому не годится для измерения временных интервалов - точное время нахождения потока в сосотянии ожидания зависит от реализации в операционной системе.

## Прерывания

Прерывания возникают когда один поток вызывает метод `interrupt()` другого потока. Корректная обработка прерываний - это целиком на совести разработчика. Для коротких задач нет смысла добавлять обработку прерывания. Для длинных задач (например, с использованием бесконечного цикла) обработка прерывания позволяет корректно завершить задачу, например закрыть закрывать, закоммитить транзакцию, отправить сообщение и т.д.

Для корректной обработки поток периодически должен проверять статус флага прерывания статическим методом `Thread.interrupted()` или `currentThread().isInterrupted()`. Первый проверяет флаг и сбрасывает его в false. Второй только проверяет, но не сбрасывает.

```java
public class DigitalHabits implements Runnable {

    public void run() {
        //start of work - open files, open transactions, etc
        while (true) {
            //do bit of work
            if (Thread.interrupted()) {
                System.out.println("I'm interrupted.");
                //do something to complete work - close files, commit transactions, etc
                break;
            }
        }
    }
}
```

## `join()`

Чтоб дождаться завершения выполнения другого потока, мы можем вызвать его метод `join()`. В этом случае текущий поток прервется до тех пор, пока не выполнится другой. `join()` так же перегружен и позволяет вызвать его с параметром типа `long` чтоб ограничить время ожидания определенным количеством милисекунд. После этого мы можем проверить завершился ли потом методом `isAlive()`. `join()` работает аналогично `sleep()` и может быть прерван исключением `InterruptedException`.

```java
public class Main {
    public static void main(String args[]) throws InterruptedException {
        Thread thread = new Thread(new DigitalHabits());
        thread.start();

        System.out.println("Main  : Waiting for thread for 2 sec");
        thread.join(2000);
        if (thread.isAlive()) {
            System.out.println("Main  : thread is alive. waiting for completion");
            thread.join();
            if (thread.isAlive()) {
                throw new RuntimeException("It is impossible!!!");
            }
        }
        System.out.println("Main  : thread completed");
    }
}
```

## Синхронизция

### Проблемы многопоточной работы

#### Столкновения потоков (Thread Interference)

Общий доступ из разных потоков к полям одного объекта может приводить к непредсказуемым результатам. Например если переменную int n используют два потока и оба выполняют операцию n++ одновременно то может произойти такая ситуация - первый поток берет значение переменной, оно равно x, второй поток берет значение переменной, так же x. Далее оба потока добавляют к нему еденицу и получают x+1, после этого оба потока записывают значение переменной в память. Ожидаемый результат после выполнения двух операций n++ будет x+2, а фактически там будет записано x+1. Для избежания подобных ситуаций используются различные механики синхронизаций.

#### Ошибки консистености памяти 

В java для ускорения работы есть потоковые кеши в которые копируются данные для ускорения работы методов и потоков. Поэтому изменение переменной в потоке A могут быть не видны потоку B, даже если событие чтения переменной в потоке B произошло после события записи этой же переменной в потоке A. Во избежание таких ситуаций есть инструменты синхронизации потоков и данных, которые будут рассмотрены ниже.


### Инструменты синхронизации 

#### `synchronized` методы

Ключевое слово `synchronized` в опеределении метода указывает на то, что только один поток может вызывать метод объекта с таким ключевым словом. Т.е. даже если синхронизированных методов несколько штук и различные потоки пытаются вызвать разные методы - в каждый момент времени только один синхронизированный метод объекта может выполняться только одним потоком. Остальне в это время находятся в ожидании пока активный поток не закончит выполнять синхронизированный метод.

Дополнительно, `synchronized`-метод гарантирует что сразу после его выполнения любые другие потоки не будут испытывать проблем с консистеностью памяти - т.е. значения переменных из локальных кешей будут перенесены в общую память.

Конструкторы не могут быть синхронизированны - это не имеет смысла т.к. создание объекта производится в одном и только одном потоке. Попытка сделать конструктор синхронизированным приведет к ошибке компиляции.

`synchronized`-методы являются одним из простейших способом создать thread-safe класс. Это эффективно, но злоупотребление синхронизацией может привести к взаимным блокировкам потоков.

```java
public class SyncIncrementer {
  private int c = 0;
  public synchronized void inc() {
    c++;
  }
  public synchronized int get() {
    return c;
  }
}
```

#### мониторы / внутренние блокировки / `synchronized` блоки 

Каждый объект имеет особое поле предназначение для организации эксклюзивного доступа. Такой механизм называется внутренной блокировкой (*intrinsic lock*) или монитором (*monitor*). Поток, которому необходим монопольный доступ к объекту должен получить (или захватить) монитор объекта и освободить его после того как необходимые изменения в объект будут внесены. Это гарантирует синхронизированный доступ к объекту и позволяет вызвать последовательно несколько изменений или методов.

`synchronized`-метод именно по такой схеме и работает - перед начал выполнения `synchronized`-метода берется монитор объекта после чего выполняется метод, и только после завершения выполнения `synchronized`-метода монитор объекта освобождается.

Статический `synchronized`-метод пользуется монитором объекта типа `Class` - поэтому нужно быть осторожным используя статические синхронизированные методы - единовременно только один поток приложения сможет выполнять этот метод, даже если его вызывают одновременно десятки объектов этого класса.

```java
public void addStudent(String name) {
  synchronized(this) {
    lastStudent = name;
    totalCount++;
  }
}
```

#### `volatile`

Ключевое слово `volatile` используется для объявления переменных и указывает на то что изменения переменной одним поток незамедлительно становятся видны остальным потокам. Т.е. все операции чтения и записи производятся напрямую в общую память, а не в кеш потока. Таким образом это позволяет снизить ошибки консистентности при плотном использовании общих переменных большим количеством потоков.


## "Живучесть" многопоточного приложения

При создании многопоточных приложений и использовании синхронизаций возникают новые проблемы, возможность которых нужно учитывать при планировании схемы взаимодействия потоков и данных - deadlock (тупик), starvation (голод), livelock (заморозка)

### Тупик (deadlock)

Тупик возникает когда два потока захватывают мониторы одних и тех же объектов в разной последовательности. Например, поток A захватывает монитор объекта X, а потом B захватывает монитор объекта Y. Через некоторое время потоку A понадобился монитор объекта Y и он становится в ожидании освобождения монитора объекта Y. В это время потоку B необходим монитор объекта X. Таким образом обоим потокам нужны мониторы двух объектов, но они не могут их получить и начинают ожидать бесконечно.

Основные способы избежания таких ситуаций - избегать архитектуры в которой необходимо блокировать много ресурсов, блокировать ресурсы всегда в одной последовательности, освобождать мониторы сразу как только в них больше нет необходимости.

### Голод и заморозка (Starvation and Livelock) 

Состояние голода возникает когда на объекте несколько synchronized методов и один из них отрабатывает долго, либо очень часто вызывается каким-то потоком. Таким образом это будет часто или надолго блокировать объект, что приведет к медленной работе других потоков, даже если синхронизированные методы которые им нужны сами по себе легкие и быстровыполняющиеся.

Состояние заморозки может возникать когда два потока реагируют на состояние друг друга и в зависимости от состяния потока выполняют определенные действия, которые при дальнейшей проверке другим потоком приводят к его зерклальным действиям. Например работают два потока и оба хотят сделать запрос на удаленный сервер, но разрешен только один одновременный запрос. Они оба возводят флаг что начинают операцию, потом проверяют в другом потоке этот же флаг, видят что он запущен и оба завершают операцию, чтоб дать другому потоку закончить оепрацию. В итоге никто из них вовремя не сделал эту операцию, это может повторяться достаточно долго пока тайминги выполнения потоков не сместятся так, что проверка флага одним из потоков не пройдет до взвода другим потоком этого флага.

## `wait`, `notify`, `notifyAll`



# Источники
1. https://docs.oracle.com/javase/tutorial/essential/concurrency/
1. 
